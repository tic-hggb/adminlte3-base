'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var postcss = _interopDefault(require('postcss'));
var selectorParser = _interopDefault(require('postcss-selector-parser'));
var valueParser = _interopDefault(require('postcss-value-parser'));

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

var name = "postcss-scrollbar";

const defaults = {
  edgeAutohide: false
};
const widthMap = {
  auto: 'initial',
  thin: '0.5rem',
  none: '0'
};
const colorMap = {
  auto: 'initial',
  dark: 'initial',
  light: 'initial'
};
var index = postcss.plugin(name, (options = defaults) => (css, result) => {
  css.walkDecls(/^scrollbar/, decl => {
    if (decl.prop === 'scrollbar-width') {
      return processWidth(decl);
    }

    if (decl.prop === 'scrollbar-color') {
      return processColor(decl);
    }
  });

  function processWidth(decl) {
    let {
      parent,
      value: keyword
    } = decl;
    let root = parent.parent;

    if (!/auto|thin|none/.test(keyword)) {
      return decl.warn(result, 'Invalid value for property `scrollbar-width`. ' + 'Must be one of `auto | thin | none`.', {
        word: keyword
      });
    }

    let processor = selectorParser(selectors => {
      selectors.each(selector => {
        selector.append(selectorParser.pseudo({
          value: '::-webkit-scrollbar'
        }));
      });
    });
    let newRule = postcss.rule({
      selector: processor.processSync(parent.selector)
    });
    newRule.append(postcss.decl({
      prop: 'width',
      value: widthMap[keyword]
    }));
    newRule.append(postcss.decl({
      prop: 'height',
      value: widthMap[keyword]
    }));
    root.insertBefore(parent, newRule);
    let value = options.edgeAutohide ? '-ms-autohiding-scrollbar' : keyword === 'none' ? 'none' : 'auto';
    parent.insertBefore(decl, {
      prop: '-ms-overflow-style',
      value
    });
  }

  function processColor(decl) {
    let {
      nodes
    } = valueParser(decl.value);

    if (nodes.length === 1 && !/auto|dark|light/.test(nodes[0].value)) {
      return decl.warn(result, 'Invalid value for property `scrollbar-color`. ' + 'Must be one of `auto | dark | light | <color> <color>`.', {
        word: nodes[0].value
      });
    }

    let values = nodes.filter(value => value.type === 'word').reduce((acc, curr, idx) => {
      if (idx >= 1) {
        return _objectSpread({}, acc, {
          track: colorMap[curr.value] || curr.value,
          corner: colorMap[curr.value] || curr.value
        });
      }

      return {
        thumb: colorMap[curr.value] || curr.value,
        track: colorMap[curr.value] || curr.value,
        corner: colorMap[curr.value] || curr.value
      };
    }, {});
    let {
      parent
    } = decl;
    let root = parent.parent;
    Object.keys(values).forEach(pseudo => {
      let processor = selectorParser(selectors => {
        selectors.each(selector => {
          selector.append(selectorParser.pseudo({
            value: `::-webkit-scrollbar-${pseudo}`
          }));
        });
      });
      let newRule = postcss.rule({
        selector: processor.processSync(parent.selector)
      }).append(postcss.decl({
        prop: 'background-color',
        value: values[pseudo]
      }));
      root.insertBefore(parent, newRule);
    });
  }
});

module.exports = index;
